---
id: add-custom-dto
title: How to add a custom DTO
sidebar_label: Add a custom DTO
slug: /custom-code/custom-dto
---

# How to add a custom DTO

## General
A DTO (Data Access Object) is an object that defines how the data will be sent over the network. 
DTOs can be defined by TypeScript interfaces or by classes. Though, it is preferable to use classes as TypeScript interfaces are removed during the transpilation, and can't be referred an at runtime. However, classes are part of the JavaScript ES6 standard and are therefore preserved as real entities in the compiled JavaScript.

The DTOs in Amplication are generated based on the relations between the entities and Prisma schema and types.
Sometimes you have use-cases where you need DTOs supported by Prisma but not generated by Amplication yet.

## Example
The following example will demonstrate how to add a new custom DTO to your application and how to use it through the application instead of the base DTO.

## Adding a new DTO
1. Determine which DTO you need. For example, let's say you have an application with a Customer entity, and you want to filter all the customers with the `customerType` property - "Gold". On the generated app, you will get a DTO named `CustomerFindManyArgs` with a field (for GraphQL) or ApiProperty (for REST) from type: `CustomerWhereInput`.

```typescript
@ApiProperty({
    required: false,
    type: () => CustomerWhereInput,
})
@Field(() => CustomerWhereInput, { nullable: true })
@Type(() => CustomerWhereInput)
where?: CustomerWhereInput;
```
`CustomerWhereInput` has its own fields/API properties, including `EnumCustomerCustomerType`

```typescript
@ApiProperty({
    required: false,
    enum: EnumCustomerCustomerType,
})
@IsEnum(EnumCustomerCustomerType)
@IsOptional()
@Field(() => EnumCustomerCustomerType, { nullable: true })
customerType?: "Gold" | "Silver" | "Regular";
```

`EnumCustomerCustomerType` is only an enum, not a DTO, meaning you can't filter with it. 

```typescript
export enum EnumCustomerCustomerType {
  Gold = "Gold",
  Silver = "Silver",
  Regular = "Regular",
}
```

In Amplication, we support string filtering, but not enums filtering. Thus, in this case we need to create a custom DTO. 

2. Find the right DTO - according to Prisma, `EntityWhereInput` wraps all model fields in a type so that the list can be **filtered by any property**. 

[Prisma findMany](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#findmany)

`CustomerWhereInput` that generated by Prisma:

```typescript
export type CustomerWhereInput = {
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
    addressId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    customerType?: EnumEnumCustomerCustomerTypeFilter | EnumCustomerCustomerType
    email?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    id?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    orders?: OrderListRelationFilter
    phone?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
}
```

The Customer model from Prisma schema:

```prisma
model Customer {
  address      Address?                 @relation(fields: [addressId], references: [id])
  addressId    String?
  createdAt    DateTime                 @default(now())
  customerType EnumCustomerCustomerType
  email        String?
  firstName    String?
  id           String                   @id @default(cuid())
  lastName     String?
  orders       Order[]
  phone        String?
  updatedAt    DateTime                 @updatedAt
}
```

The type that we are looking for is the type of the property `customerType`:  `EnumEnumCustomerCustomerTypeFilter`

```typescript
export type EnumEnumCustomerCustomerTypeFilter = {
    equals?: EnumCustomerCustomerType
    in?: Enumerable<EnumCustomerCustomerType>
    notIn?: Enumerable<EnumCustomerCustomerType>
    not?: NestedEnumEnumCustomerCustomerTypeFilter | EnumCustomerCustomerType
}
```

3. Create a custom DTO from this type:
    - in the customer folder, create a new folder named `dtos`
    - inside this folder, create a two new files: `CustomerWhereInputWithFilterEnum.dto.ts` and `EnumEnumCustomerCustomerTypeFilter.dto.ts`
    - in `EnumEnumCustomerCustomerTypeFilter.dto.ts` file create a new class `EnumEnumCustomerCustomerTypeFilter` with the following properties: (equals, in, notIn, not) as you can see above.
    - in `CustomerWhereInputWithFilterEnum.dto.ts` file create a new class `CustomerWhereInputWithFilterEnum` decorated by `@InputType()`
    - this class should look exactly like `CustomerWhereInput`, except the type of `customerType` field/API property. In this case, its type should be `EnumEnumCustomerCustomerTypeFilter`

4. Change the type of the `where` property in `CustomerFindManyArgs` to `CustomerWhereInputWithFilterEnum`

### line-by-line instructions
In `/server/src/customer/dtos/EnumEnumCustomerCustomerTypeFilter.dto.ts`
create a new class `EnumEnumCustomerCustomerTypeFilter` with the properties `equals`, `in`, `notIn` and  `not`:

```typescript
import { Field, InputType } from "@nestjs/graphql";
import { ApiProperty } from "@nestjs/swagger";
import { IsOptional } from "class-validator";
import { Type } from "class-transformer";
import { EnumCustomerCustomerType } from "../base/EnumCustomerCustomerType";

@InputType({
  isAbstract: true,
})
export class EnumEnumCustomerCustomerTypeFilter {
  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  @Type(() => String)
  equals?: EnumCustomerCustomerType;

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [EnumCustomerCustomerType], {
    nullable: true,
  })
  @Type(() => String)
  in?: EnumCustomerCustomerType[];

  @ApiProperty({
    required: false,
    type: [String],
  })
  @IsOptional()
  @Field(() => [EnumCustomerCustomerType], {
    nullable: true,
  })
  @Type(() => String)
  notIn?: EnumCustomerCustomerType[];

  @ApiProperty({
    required: false,
    type: String,
  })
  @IsOptional()
  @Field(() => EnumCustomerCustomerType, {
    nullable: true,
  })
  @Type(() => String)
  not?: EnumEnumCustomerCustomerTypeFilter;
}
```

In `/server/src/customer/dtos/CustomerWhereInputWithFilterEnum.dto.ts`
Create a new class `CustomerWhereInputWithFilterEnum` decorated by `@InputType()`:

```typescript
@InputType()
class CustomerWhereInputWithFilterEnum {
    @ApiProperty({
        required: false,
        enum: EnumEnumCustomerCustomerTypeFilter,
    })
    @IsEnum(EnumEnumCustomerCustomerTypeFilter)
    @IsOptional()
    @Field(() => EnumEnumCustomerCustomerTypeFilter, {
    nullable: true,
    })
    customerType?: EnumEnumCustomerCustomerTypeFilter;
}       
```
As mentioned earlies, this class should look exactly like `CustomerWhereInput`. Therefore, you need to copy and paste the other properties from the `CustomerWhereInput` DTO.

In `/server/src/customer/base/CustomerFindManyArgs.ts`, change the type of the `where` property to `CustomerWhereInputWithFilterEnum`:

```ts
import { CustomerWhereInputWithFilterEnum } from "../dtos/CustomerWhereInputWithFilterEnum";

@ArgsType()
class CustomerFindManyArgs {
  @ApiProperty({
    required: false,
    type: () => CustomerWhereInputWithFilterEnum,
  })
  @Field(() => CustomerWhereInputWithFilterEnum, { nullable: true })
  @Type(() => CustomerWhereInputWithFilterEnum)
  where?: CustomerWhereInputWithFilterEnum;
}
```

## Check your changes

You are ready to check your changes. Just save all changes and restart your server.
Navigate to http://localhost:3000/graphql/ for GraphQL and http://localhost:3000/api/ for REST to see and execute the new query.

:::tip
You can run your server in watch mode, which automatically restarts whenever a file in the server code is changed.
Instead of using **npm start**, you should use this command.

```
nest start --debug --watch
```

:::
